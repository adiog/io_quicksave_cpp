// This file is an AUTOGENERATED part of beans project.
// Copyright (c) 2017 Aleksander Gajewski <adiog@quicksave.io>.

#pragma once

#include <CppBeans.h>

#include <memory>
#include <folly/io/IOBuf.h>
#include <rapidjson/document.h>
#include <rapidjson/stringbuffer.h>
#include <rapidjson/writer.h>


namespace qs {

class DatabaseTaskBean
{
public:
    DatabaseTaskBean() = default;

    DatabaseTaskBean(const char* json)
            : DatabaseTaskBean(rapidjson::Document{}.Parse(json))
    {
    }

    DatabaseTaskBean(SerializedDict beanjson, std::string beanname, std::string databaseConnectionString, std::string type)
            : beanjson(beanjson)
            , beanname(beanname)
            , databaseConnectionString(databaseConnectionString)
            , type(type)
    {
    }

    DatabaseTaskBean(const rapidjson::Value& value)
    {
        if (value.HasMember(beanjson_label))
            this->beanjson = Typoid<SerializedDict>::FromValue(value[beanjson_label]);
        else
            throw(missing_mandatory_field(beanjson_label));
        if (value.HasMember(beanname_label))
            this->beanname = Typoid<std::string>::FromValue(value[beanname_label]);
        else
            throw(missing_mandatory_field(beanname_label));
        if (value.HasMember(databaseConnectionString_label))
            this->databaseConnectionString = Typoid<std::string>::FromValue(value[databaseConnectionString_label]);
        else
            throw(missing_mandatory_field(databaseConnectionString_label));
        if (value.HasMember(type_label))
            this->type = Typoid<std::string>::FromValue(value[type_label]);
        else
            throw(missing_mandatory_field(type_label));
    }

    void update(DatabaseTaskBean bean)
    {
        beanjson = bean.beanjson;
        beanname = bean.beanname;
        databaseConnectionString = bean.databaseConnectionString;
        type = bean.type;
    }

    template <typename Writer>
    void Serialize(Writer& writer) const
    {
        writer.StartObject();
        writer.String(beanjson_label);
        Typoid<SerializedDict>::Serialize(beanjson, writer);
        writer.String(beanname_label);
        Typoid<std::string>::Serialize(beanname, writer);
        writer.String(databaseConnectionString_label);
        Typoid<std::string>::Serialize(databaseConnectionString, writer);
        writer.String(type_label);
        Typoid<std::string>::Serialize(type, writer);
        writer.EndObject();
    }

    friend std::ostream& operator<<(std::ostream& os, const DatabaseTaskBean& bean)
    {
        rapidjson::StringBuffer s;
        rapidjson::PrettyWriter<rapidjson::StringBuffer> writer(s);
        bean.Serialize(writer);
        os << s.GetString();
        return os;
    }

    std::string to_string() const
    {
        rapidjson::StringBuffer s;
        rapidjson::Writer<rapidjson::StringBuffer> writer(s);
        Serialize(writer);
        return s.GetString();
    }

    operator std::unique_ptr<folly::IOBuf>() const { return folly::IOBuf::copyBuffer(::serialize(*this)); }

    const char* __name__ = "DatabaseTaskBean";
    SerializedDict beanjson;
    const char* beanjson_label = "beanjson";
    std::string beanname;
    const char* beanname_label = "beanname";
    std::string databaseConnectionString;
    const char* databaseConnectionString_label = "databaseConnectionString";
    std::string type;
    const char* type_label = "type";
};
}
