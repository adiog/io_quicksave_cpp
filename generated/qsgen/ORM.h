// This file is an AUTOGENERATED part of beans project.
// Copyright (c) 2017 Aleksander Gajewski <adiog@quicksave.io>.

#pragma once

#include <iostream>
#include <string>

#include <folly/Format.h>

#include <sqlpp11/alias_provider.h>
#include <sqlpp11/char_sequence.h>
#include <sqlpp11/column_types.h>
#include <sqlpp11/custom_query.h>
#include <sqlpp11/functions.h>
#include <sqlpp11/insert.h>
#include <sqlpp11/multi_column.h>
#include <sqlpp11/remove.h>
#include <sqlpp11/select.h>
#include <sqlpp11/table.h>
#include <sqlpp11/transaction.h>
#include <sqlpp11/update.h>

#include <sqlpp11/postgresql/connection.h>
#include <sqlpp11/sqlite3/connection.h>

#include <CppBeans.h>

#include <qsgen/ABI.h>
#include <qsgen/orm/sqlppTables.h>

#include <qs/util/hash.h>


namespace qs {

template <typename T>
class ORM;
}
namespace qs {

template <>
class ORM<MetaBean>
{
public:
    static qs::orm::Meta& getTable()
    {
        static qs::orm::Meta table{};
        return table;
    }

    template <typename Row>
    static MetaBean constructor(const Row& row)
    {
        MetaBean bean;
        if (!row.metaHash.is_null()) bean.meta_hash = row.metaHash.value();
        if (!row.author.is_null()) bean.author = row.author.value();
        if (!row.createdAt.is_null()) bean.created_at = row.createdAt.value();
        if (!row.icon.is_null()) bean.icon = row.icon.value();
        if (!row.metaType.is_null()) bean.meta_type = row.metaType.value();
        if (!row.modifiedAt.is_null()) bean.modified_at = row.modifiedAt.value();
        if (!row.name.is_null()) bean.name = row.name.value();
        if (!row.sourceTitle.is_null()) bean.source_title = row.sourceTitle.value();
        if (!row.sourceUrl.is_null()) bean.source_url = row.sourceUrl.value();
        if (!row.text.is_null()) bean.text = row.text.value();
        if (!row.userHash.is_null()) bean.user_hash = row.userHash.value();
        return bean;
    }

    static List<MetaBean> query(sqlpp::connection& db, const std::string& sqlQuery)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return queryImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), sqlQuery);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return queryImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), sqlQuery);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static absl::optional<MetaBean> get(sqlpp::connection& db, const std::string& hash)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return getImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), hash);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return getImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), hash);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    template <typename ColumnName, typename ColumnType>
    static List<MetaBean> getBy(sqlpp::connection& db, const ColumnName& column, const ColumnType& column_value)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return getByImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), column, column_value);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return getByImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), column, column_value);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void remove(sqlpp::connection& db, const std::string& hash)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return removeImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), hash);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return removeImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), hash);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    template <typename ColumnName, typename ColumnType>
    static void removeBy(sqlpp::connection& db, const ColumnName& column, const ColumnType& column_value)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return removeByImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), column, column_value);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return removeByImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), column, column_value);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static std::string insert(sqlpp::connection& db, MetaBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return insertImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return insertImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void update(sqlpp::connection& db, const MetaBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return updateImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return updateImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void override(sqlpp::connection& db, const MetaBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return overrideImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return overrideImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

private:
    template <typename DatabaseConnection>
    static List<MetaBean> queryImplementation(DatabaseConnection& db, const std::string& sqlQuery)
    {
        const auto table = getTable();

        List<MetaBean> result(0);

        try
        {
            for (const auto& row : db(
                     sqlpp::custom_query(sqlpp::verbatim(sqlQuery))
                         .with_result_type_of(sqlpp::select(all_of(table)))))
            {
                result.push_back(constructor(row));
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
            return result;
        }

        return result;
    }

    template <typename DatabaseConnection>
    static absl::optional<MetaBean> getImplementation(DatabaseConnection& db, const std::string& hash)
    {
        const auto table = getTable();

        try
        {
            for (const auto& row : db(select(all_of(table)).from(table).where(table.metaHash == hash).limit(1U)))
            {
                return constructor(row);
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }

        return absl::nullopt;
    }

    template <typename DatabaseConnection, typename ColumnName, typename ColumnType>
    static List<MetaBean> getByImplementation(DatabaseConnection& db, const ColumnName& column, const ColumnType& column_value)
    {
        const auto table = getTable();

        List<MetaBean> result(0);

        try
        {
            for (const auto& row : db(select(all_of(table)).from(table).where(column == column_value)))
            {
                result.push_back(constructor(row));
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }

        return result;
    }

    template <typename DatabaseConnection>
    static void removeImplementation(DatabaseConnection& db, const std::string& hash)
    {
        const auto table = getTable();

        db(remove_from(table).where(table.metaHash == hash));
    }

    template <typename DatabaseConnection, typename ColumnName, typename ColumnType>
    static void removeByImplementation(DatabaseConnection& db, const ColumnName& column, const ColumnType& column_value)
    {
        const auto table = getTable();

        db(remove_from(table).where(column == column_value));
    }

    template <typename DatabaseConnection>
    static std::string insertImplementation(DatabaseConnection& db, MetaBean& bean)
    {
        try
        {
            const auto table = getTable();

            if (!bean.meta_hash) bean.meta_hash = qs::util::Hash::get();

            auto prepareStatement = db.prepare(sqlpp::insert_into(table).set(
                (table.metaHash = parameter(table.metaHash)),
                (table.author = parameter(table.author)),
                (table.createdAt = parameter(table.createdAt)),
                (table.icon = parameter(table.icon)),
                (table.metaType = parameter(table.metaType)),
                (table.modifiedAt = parameter(table.modifiedAt)),
                (table.name = parameter(table.name)),
                (table.sourceTitle = parameter(table.sourceTitle)),
                (table.sourceUrl = parameter(table.sourceUrl)),
                (table.text = parameter(table.text)),
                (table.userHash = parameter(table.userHash))));

            if (bean.meta_hash)
            {
                prepareStatement.params.metaHash = (*bean.meta_hash);
            }
            if (bean.author)
            {
                prepareStatement.params.author = (*bean.author);
            }
            if (bean.created_at)
            {
                prepareStatement.params.createdAt = (*bean.created_at);
            }
            if (bean.icon)
            {
                prepareStatement.params.icon = (*bean.icon);
            }
            if (bean.meta_type)
            {
                prepareStatement.params.metaType = (*bean.meta_type);
            }
            if (bean.modified_at)
            {
                prepareStatement.params.modifiedAt = (*bean.modified_at);
            }
            if (bean.name)
            {
                prepareStatement.params.name = (*bean.name);
            }
            if (bean.source_title)
            {
                prepareStatement.params.sourceTitle = (*bean.source_title);
            }
            if (bean.source_url)
            {
                prepareStatement.params.sourceUrl = (*bean.source_url);
            }
            if (bean.text)
            {
                prepareStatement.params.text = (*bean.text);
            }
            if (bean.user_hash)
            {
                prepareStatement.params.userHash = (*bean.user_hash);
            }

            db(prepareStatement);

            return *bean.meta_hash;
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    template <typename DatabaseConnection>
    static void updateImplementation(DatabaseConnection& db, const MetaBean& bean)
    {
        try
        {
            const auto table = getTable();

            auto optOrigBean = getImplementation(db, *bean.meta_hash);
            auto& origBean = *optOrigBean;

            if (bean.meta_hash)
            {
                origBean.meta_hash = bean.meta_hash;
            }
            if (bean.author)
            {
                origBean.author = bean.author;
            }
            if (bean.created_at)
            {
                origBean.created_at = bean.created_at;
            }
            if (bean.icon)
            {
                origBean.icon = bean.icon;
            }
            if (bean.meta_type)
            {
                origBean.meta_type = bean.meta_type;
            }
            if (bean.modified_at)
            {
                origBean.modified_at = bean.modified_at;
            }
            if (bean.name)
            {
                origBean.name = bean.name;
            }
            if (bean.source_title)
            {
                origBean.source_title = bean.source_title;
            }
            if (bean.source_url)
            {
                origBean.source_url = bean.source_url;
            }
            if (bean.text)
            {
                origBean.text = bean.text;
            }
            if (bean.user_hash)
            {
                origBean.user_hash = bean.user_hash;
            }

            overrideImplementation(db, origBean);
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    template <typename DatabaseConnection>
    static void overrideImplementation(DatabaseConnection& db, const MetaBean& bean)
    {
        try
        {
            const auto table = getTable();

            auto prepareStatement = db.prepare(sqlpp::update(table).set(
                                                                       (table.metaHash = parameter(table.metaHash)),
                                                                       (table.author = parameter(table.author)),
                                                                       (table.createdAt = parameter(table.createdAt)),
                                                                       (table.icon = parameter(table.icon)),
                                                                       (table.metaType = parameter(table.metaType)),
                                                                       (table.modifiedAt = parameter(table.modifiedAt)),
                                                                       (table.name = parameter(table.name)),
                                                                       (table.sourceTitle = parameter(table.sourceTitle)),
                                                                       (table.sourceUrl = parameter(table.sourceUrl)),
                                                                       (table.text = parameter(table.text)),
                                                                       (table.userHash = parameter(table.userHash)))
                                                   .where(table.metaHash == *bean.meta_hash));

            if (bean.meta_hash)
            {
                prepareStatement.params.metaHash = (*bean.meta_hash);
            }
            if (bean.author)
            {
                prepareStatement.params.author = (*bean.author);
            }
            if (bean.created_at)
            {
                prepareStatement.params.createdAt = (*bean.created_at);
            }
            if (bean.icon)
            {
                prepareStatement.params.icon = (*bean.icon);
            }
            if (bean.meta_type)
            {
                prepareStatement.params.metaType = (*bean.meta_type);
            }
            if (bean.modified_at)
            {
                prepareStatement.params.modifiedAt = (*bean.modified_at);
            }
            if (bean.name)
            {
                prepareStatement.params.name = (*bean.name);
            }
            if (bean.source_title)
            {
                prepareStatement.params.sourceTitle = (*bean.source_title);
            }
            if (bean.source_url)
            {
                prepareStatement.params.sourceUrl = (*bean.source_url);
            }
            if (bean.text)
            {
                prepareStatement.params.text = (*bean.text);
            }
            if (bean.user_hash)
            {
                prepareStatement.params.userHash = (*bean.user_hash);
            }

            db(prepareStatement);
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }
};
}

namespace qs {

template <>
class ORM<FileBean>
{
public:
    static qs::orm::File& getTable()
    {
        static qs::orm::File table{};
        return table;
    }

    template <typename Row>
    static FileBean constructor(const Row& row)
    {
        FileBean bean;
        if (!row.fileHash.is_null()) bean.file_hash = row.fileHash.value();
        bean.filename = row.filename.value();
        bean.filesize = row.filesize.value();
        bean.meta_hash = row.metaHash.value();
        bean.mimetype = row.mimetype.value();
        return bean;
    }

    static List<FileBean> query(sqlpp::connection& db, const std::string& sqlQuery)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return queryImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), sqlQuery);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return queryImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), sqlQuery);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static absl::optional<FileBean> get(sqlpp::connection& db, const std::string& hash)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return getImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), hash);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return getImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), hash);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    template <typename ColumnName, typename ColumnType>
    static List<FileBean> getBy(sqlpp::connection& db, const ColumnName& column, const ColumnType& column_value)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return getByImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), column, column_value);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return getByImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), column, column_value);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void remove(sqlpp::connection& db, const std::string& hash)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return removeImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), hash);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return removeImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), hash);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    template <typename ColumnName, typename ColumnType>
    static void removeBy(sqlpp::connection& db, const ColumnName& column, const ColumnType& column_value)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return removeByImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), column, column_value);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return removeByImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), column, column_value);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static std::string insert(sqlpp::connection& db, FileBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return insertImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return insertImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void update(sqlpp::connection& db, const FileBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return updateImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return updateImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void override(sqlpp::connection& db, const FileBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return overrideImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return overrideImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

private:
    template <typename DatabaseConnection>
    static List<FileBean> queryImplementation(DatabaseConnection& db, const std::string& sqlQuery)
    {
        const auto table = getTable();

        List<FileBean> result(0);

        try
        {
            for (const auto& row : db(
                     sqlpp::custom_query(sqlpp::verbatim(sqlQuery))
                         .with_result_type_of(sqlpp::select(all_of(table)))))
            {
                result.push_back(constructor(row));
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
            return result;
        }

        return result;
    }

    template <typename DatabaseConnection>
    static absl::optional<FileBean> getImplementation(DatabaseConnection& db, const std::string& hash)
    {
        const auto table = getTable();

        try
        {
            for (const auto& row : db(select(all_of(table)).from(table).where(table.fileHash == hash).limit(1U)))
            {
                return constructor(row);
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }

        return absl::nullopt;
    }

    template <typename DatabaseConnection, typename ColumnName, typename ColumnType>
    static List<FileBean> getByImplementation(DatabaseConnection& db, const ColumnName& column, const ColumnType& column_value)
    {
        const auto table = getTable();

        List<FileBean> result(0);

        try
        {
            for (const auto& row : db(select(all_of(table)).from(table).where(column == column_value)))
            {
                result.push_back(constructor(row));
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }

        return result;
    }

    template <typename DatabaseConnection>
    static void removeImplementation(DatabaseConnection& db, const std::string& hash)
    {
        const auto table = getTable();

        db(remove_from(table).where(table.fileHash == hash));
    }

    template <typename DatabaseConnection, typename ColumnName, typename ColumnType>
    static void removeByImplementation(DatabaseConnection& db, const ColumnName& column, const ColumnType& column_value)
    {
        const auto table = getTable();

        db(remove_from(table).where(column == column_value));
    }

    template <typename DatabaseConnection>
    static std::string insertImplementation(DatabaseConnection& db, FileBean& bean)
    {
        try
        {
            const auto table = getTable();

            if (!bean.file_hash) bean.file_hash = qs::util::Hash::get();

            auto prepareStatement = db.prepare(sqlpp::insert_into(table).set(
                (table.fileHash = parameter(table.fileHash)),
                (table.filename = parameter(table.filename)),
                (table.filesize = parameter(table.filesize)),
                (table.metaHash = parameter(table.metaHash)),
                (table.mimetype = parameter(table.mimetype))));

            if (bean.file_hash)
            {
                prepareStatement.params.fileHash = (*bean.file_hash);
            }
            prepareStatement.params.filename = bean.filename;
            prepareStatement.params.filesize = bean.filesize;
            prepareStatement.params.metaHash = bean.meta_hash;
            prepareStatement.params.mimetype = bean.mimetype;

            db(prepareStatement);

            return *bean.file_hash;
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    template <typename DatabaseConnection>
    static void updateImplementation(DatabaseConnection& db, const FileBean& bean)
    {
        try
        {
            const auto table = getTable();

            auto optOrigBean = getImplementation(db, *bean.file_hash);
            auto& origBean = *optOrigBean;

            if (bean.file_hash)
            {
                origBean.file_hash = bean.file_hash;
            }
            origBean.filename = bean.filename;
            origBean.filesize = bean.filesize;
            origBean.meta_hash = bean.meta_hash;
            origBean.mimetype = bean.mimetype;

            overrideImplementation(db, origBean);
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    template <typename DatabaseConnection>
    static void overrideImplementation(DatabaseConnection& db, const FileBean& bean)
    {
        try
        {
            const auto table = getTable();

            auto prepareStatement = db.prepare(sqlpp::update(table).set(
                                                                       (table.fileHash = parameter(table.fileHash)),
                                                                       (table.filename = parameter(table.filename)),
                                                                       (table.filesize = parameter(table.filesize)),
                                                                       (table.metaHash = parameter(table.metaHash)),
                                                                       (table.mimetype = parameter(table.mimetype)))
                                                   .where(table.fileHash == *bean.file_hash));

            if (bean.file_hash)
            {
                prepareStatement.params.fileHash = (*bean.file_hash);
            }
            prepareStatement.params.filename = bean.filename;
            prepareStatement.params.filesize = bean.filesize;
            prepareStatement.params.metaHash = bean.meta_hash;
            prepareStatement.params.mimetype = bean.mimetype;

            db(prepareStatement);
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }
};
}

namespace qs {

template <>
class ORM<ActionBean>
{
public:
    static qs::orm::Action& getTable()
    {
        static qs::orm::Action table{};
        return table;
    }

    template <typename Row>
    static ActionBean constructor(const Row& row)
    {
        ActionBean bean;
        if (!row.actionHash.is_null()) bean.action_hash = row.actionHash.value();
        bean.kwargs = row.kwargs.value();
        bean.meta_hash = row.metaHash.value();
        bean.name = row.name.value();
        return bean;
    }

    static List<ActionBean> query(sqlpp::connection& db, const std::string& sqlQuery)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return queryImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), sqlQuery);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return queryImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), sqlQuery);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static absl::optional<ActionBean> get(sqlpp::connection& db, const std::string& hash)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return getImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), hash);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return getImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), hash);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    template <typename ColumnName, typename ColumnType>
    static List<ActionBean> getBy(sqlpp::connection& db, const ColumnName& column, const ColumnType& column_value)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return getByImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), column, column_value);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return getByImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), column, column_value);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void remove(sqlpp::connection& db, const std::string& hash)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return removeImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), hash);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return removeImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), hash);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    template <typename ColumnName, typename ColumnType>
    static void removeBy(sqlpp::connection& db, const ColumnName& column, const ColumnType& column_value)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return removeByImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), column, column_value);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return removeByImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), column, column_value);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static std::string insert(sqlpp::connection& db, ActionBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return insertImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return insertImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void update(sqlpp::connection& db, const ActionBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return updateImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return updateImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void override(sqlpp::connection& db, const ActionBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return overrideImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return overrideImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

private:
    template <typename DatabaseConnection>
    static List<ActionBean> queryImplementation(DatabaseConnection& db, const std::string& sqlQuery)
    {
        const auto table = getTable();

        List<ActionBean> result(0);

        try
        {
            for (const auto& row : db(
                     sqlpp::custom_query(sqlpp::verbatim(sqlQuery))
                         .with_result_type_of(sqlpp::select(all_of(table)))))
            {
                result.push_back(constructor(row));
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
            return result;
        }

        return result;
    }

    template <typename DatabaseConnection>
    static absl::optional<ActionBean> getImplementation(DatabaseConnection& db, const std::string& hash)
    {
        const auto table = getTable();

        try
        {
            for (const auto& row : db(select(all_of(table)).from(table).where(table.actionHash == hash).limit(1U)))
            {
                return constructor(row);
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }

        return absl::nullopt;
    }

    template <typename DatabaseConnection, typename ColumnName, typename ColumnType>
    static List<ActionBean> getByImplementation(DatabaseConnection& db, const ColumnName& column, const ColumnType& column_value)
    {
        const auto table = getTable();

        List<ActionBean> result(0);

        try
        {
            for (const auto& row : db(select(all_of(table)).from(table).where(column == column_value)))
            {
                result.push_back(constructor(row));
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }

        return result;
    }

    template <typename DatabaseConnection>
    static void removeImplementation(DatabaseConnection& db, const std::string& hash)
    {
        const auto table = getTable();

        db(remove_from(table).where(table.actionHash == hash));
    }

    template <typename DatabaseConnection, typename ColumnName, typename ColumnType>
    static void removeByImplementation(DatabaseConnection& db, const ColumnName& column, const ColumnType& column_value)
    {
        const auto table = getTable();

        db(remove_from(table).where(column == column_value));
    }

    template <typename DatabaseConnection>
    static std::string insertImplementation(DatabaseConnection& db, ActionBean& bean)
    {
        try
        {
            const auto table = getTable();

            if (!bean.action_hash) bean.action_hash = qs::util::Hash::get();

            auto prepareStatement = db.prepare(sqlpp::insert_into(table).set(
                (table.actionHash = parameter(table.actionHash)),
                (table.kwargs = parameter(table.kwargs)),
                (table.metaHash = parameter(table.metaHash)),
                (table.name = parameter(table.name))));

            if (bean.action_hash)
            {
                prepareStatement.params.actionHash = (*bean.action_hash);
            }
            prepareStatement.params.kwargs = bean.kwargs;
            prepareStatement.params.metaHash = bean.meta_hash;
            prepareStatement.params.name = bean.name;

            db(prepareStatement);

            return *bean.action_hash;
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    template <typename DatabaseConnection>
    static void updateImplementation(DatabaseConnection& db, const ActionBean& bean)
    {
        try
        {
            const auto table = getTable();

            auto optOrigBean = getImplementation(db, *bean.action_hash);
            auto& origBean = *optOrigBean;

            if (bean.action_hash)
            {
                origBean.action_hash = bean.action_hash;
            }
            origBean.kwargs = bean.kwargs;
            origBean.meta_hash = bean.meta_hash;
            origBean.name = bean.name;

            overrideImplementation(db, origBean);
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    template <typename DatabaseConnection>
    static void overrideImplementation(DatabaseConnection& db, const ActionBean& bean)
    {
        try
        {
            const auto table = getTable();

            auto prepareStatement = db.prepare(sqlpp::update(table).set(
                                                                       (table.actionHash = parameter(table.actionHash)),
                                                                       (table.kwargs = parameter(table.kwargs)),
                                                                       (table.metaHash = parameter(table.metaHash)),
                                                                       (table.name = parameter(table.name)))
                                                   .where(table.actionHash == *bean.action_hash));

            if (bean.action_hash)
            {
                prepareStatement.params.actionHash = (*bean.action_hash);
            }
            prepareStatement.params.kwargs = bean.kwargs;
            prepareStatement.params.metaHash = bean.meta_hash;
            prepareStatement.params.name = bean.name;

            db(prepareStatement);
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }
};
}

namespace qs {

template <>
class ORM<TagBean>
{
public:
    static qs::orm::Tag& getTable()
    {
        static qs::orm::Tag table{};
        return table;
    }

    template <typename Row>
    static TagBean constructor(const Row& row)
    {
        TagBean bean;
        if (!row.tagHash.is_null()) bean.tag_hash = row.tagHash.value();
        if (!row.metaHash.is_null()) bean.meta_hash = row.metaHash.value();
        if (!row.name.is_null()) bean.name = row.name.value();
        if (!row.userHash.is_null()) bean.user_hash = row.userHash.value();
        if (!row.value.is_null()) bean.value = row.value.value();
        return bean;
    }

    static List<TagBean> query(sqlpp::connection& db, const std::string& sqlQuery)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return queryImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), sqlQuery);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return queryImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), sqlQuery);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static absl::optional<TagBean> get(sqlpp::connection& db, const std::string& hash)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return getImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), hash);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return getImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), hash);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    template <typename ColumnName, typename ColumnType>
    static List<TagBean> getBy(sqlpp::connection& db, const ColumnName& column, const ColumnType& column_value)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return getByImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), column, column_value);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return getByImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), column, column_value);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void remove(sqlpp::connection& db, const std::string& hash)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return removeImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), hash);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return removeImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), hash);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    template <typename ColumnName, typename ColumnType>
    static void removeBy(sqlpp::connection& db, const ColumnName& column, const ColumnType& column_value)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return removeByImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), column, column_value);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return removeByImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), column, column_value);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static std::string insert(sqlpp::connection& db, TagBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return insertImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return insertImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void update(sqlpp::connection& db, const TagBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return updateImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return updateImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void override(sqlpp::connection& db, const TagBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return overrideImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return overrideImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

private:
    template <typename DatabaseConnection>
    static List<TagBean> queryImplementation(DatabaseConnection& db, const std::string& sqlQuery)
    {
        const auto table = getTable();

        List<TagBean> result(0);

        try
        {
            for (const auto& row : db(
                     sqlpp::custom_query(sqlpp::verbatim(sqlQuery))
                         .with_result_type_of(sqlpp::select(all_of(table)))))
            {
                result.push_back(constructor(row));
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
            return result;
        }

        return result;
    }

    template <typename DatabaseConnection>
    static absl::optional<TagBean> getImplementation(DatabaseConnection& db, const std::string& hash)
    {
        const auto table = getTable();

        try
        {
            for (const auto& row : db(select(all_of(table)).from(table).where(table.tagHash == hash).limit(1U)))
            {
                return constructor(row);
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }

        return absl::nullopt;
    }

    template <typename DatabaseConnection, typename ColumnName, typename ColumnType>
    static List<TagBean> getByImplementation(DatabaseConnection& db, const ColumnName& column, const ColumnType& column_value)
    {
        const auto table = getTable();

        List<TagBean> result(0);

        try
        {
            for (const auto& row : db(select(all_of(table)).from(table).where(column == column_value)))
            {
                result.push_back(constructor(row));
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }

        return result;
    }

    template <typename DatabaseConnection>
    static void removeImplementation(DatabaseConnection& db, const std::string& hash)
    {
        const auto table = getTable();

        db(remove_from(table).where(table.tagHash == hash));
    }

    template <typename DatabaseConnection, typename ColumnName, typename ColumnType>
    static void removeByImplementation(DatabaseConnection& db, const ColumnName& column, const ColumnType& column_value)
    {
        const auto table = getTable();

        db(remove_from(table).where(column == column_value));
    }

    template <typename DatabaseConnection>
    static std::string insertImplementation(DatabaseConnection& db, TagBean& bean)
    {
        try
        {
            const auto table = getTable();

            if (!bean.tag_hash) bean.tag_hash = qs::util::Hash::get();

            auto prepareStatement = db.prepare(sqlpp::insert_into(table).set(
                (table.tagHash = parameter(table.tagHash)),
                (table.metaHash = parameter(table.metaHash)),
                (table.name = parameter(table.name)),
                (table.userHash = parameter(table.userHash)),
                (table.value = parameter(table.value))));

            if (bean.tag_hash)
            {
                prepareStatement.params.tagHash = (*bean.tag_hash);
            }
            if (bean.meta_hash)
            {
                prepareStatement.params.metaHash = (*bean.meta_hash);
            }
            if (bean.name)
            {
                prepareStatement.params.name = (*bean.name);
            }
            if (bean.user_hash)
            {
                prepareStatement.params.userHash = (*bean.user_hash);
            }
            if (bean.value)
            {
                prepareStatement.params.value = (*bean.value);
            }

            db(prepareStatement);

            return *bean.tag_hash;
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    template <typename DatabaseConnection>
    static void updateImplementation(DatabaseConnection& db, const TagBean& bean)
    {
        try
        {
            const auto table = getTable();

            auto optOrigBean = getImplementation(db, *bean.tag_hash);
            auto& origBean = *optOrigBean;

            if (bean.tag_hash)
            {
                origBean.tag_hash = bean.tag_hash;
            }
            if (bean.meta_hash)
            {
                origBean.meta_hash = bean.meta_hash;
            }
            if (bean.name)
            {
                origBean.name = bean.name;
            }
            if (bean.user_hash)
            {
                origBean.user_hash = bean.user_hash;
            }
            if (bean.value)
            {
                origBean.value = bean.value;
            }

            overrideImplementation(db, origBean);
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    template <typename DatabaseConnection>
    static void overrideImplementation(DatabaseConnection& db, const TagBean& bean)
    {
        try
        {
            const auto table = getTable();

            auto prepareStatement = db.prepare(sqlpp::update(table).set(
                                                                       (table.tagHash = parameter(table.tagHash)),
                                                                       (table.metaHash = parameter(table.metaHash)),
                                                                       (table.name = parameter(table.name)),
                                                                       (table.userHash = parameter(table.userHash)),
                                                                       (table.value = parameter(table.value)))
                                                   .where(table.tagHash == *bean.tag_hash));

            if (bean.tag_hash)
            {
                prepareStatement.params.tagHash = (*bean.tag_hash);
            }
            if (bean.meta_hash)
            {
                prepareStatement.params.metaHash = (*bean.meta_hash);
            }
            if (bean.name)
            {
                prepareStatement.params.name = (*bean.name);
            }
            if (bean.user_hash)
            {
                prepareStatement.params.userHash = (*bean.user_hash);
            }
            if (bean.value)
            {
                prepareStatement.params.value = (*bean.value);
            }

            db(prepareStatement);
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }
};
}

namespace qs {

template <>
class ORM<KeyBean>
{
public:
    static qs::orm::Key& getTable()
    {
        static qs::orm::Key table{};
        return table;
    }

    template <typename Row>
    static KeyBean constructor(const Row& row)
    {
        KeyBean bean;
        if (!row.keyHash.is_null()) bean.key_hash = row.keyHash.value();
        bean.name = row.name.value();
        bean.user_hash = row.userHash.value();
        bean.value = row.value.value();
        return bean;
    }

    static List<KeyBean> query(sqlpp::connection& db, const std::string& sqlQuery)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return queryImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), sqlQuery);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return queryImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), sqlQuery);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static absl::optional<KeyBean> get(sqlpp::connection& db, const std::string& hash)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return getImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), hash);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return getImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), hash);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    template <typename ColumnName, typename ColumnType>
    static List<KeyBean> getBy(sqlpp::connection& db, const ColumnName& column, const ColumnType& column_value)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return getByImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), column, column_value);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return getByImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), column, column_value);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void remove(sqlpp::connection& db, const std::string& hash)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return removeImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), hash);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return removeImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), hash);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    template <typename ColumnName, typename ColumnType>
    static void removeBy(sqlpp::connection& db, const ColumnName& column, const ColumnType& column_value)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return removeByImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), column, column_value);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return removeByImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), column, column_value);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static std::string insert(sqlpp::connection& db, KeyBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return insertImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return insertImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void update(sqlpp::connection& db, const KeyBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return updateImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return updateImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void override(sqlpp::connection& db, const KeyBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return overrideImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return overrideImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

private:
    template <typename DatabaseConnection>
    static List<KeyBean> queryImplementation(DatabaseConnection& db, const std::string& sqlQuery)
    {
        const auto table = getTable();

        List<KeyBean> result(0);

        try
        {
            for (const auto& row : db(
                     sqlpp::custom_query(sqlpp::verbatim(sqlQuery))
                         .with_result_type_of(sqlpp::select(all_of(table)))))
            {
                result.push_back(constructor(row));
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
            return result;
        }

        return result;
    }

    template <typename DatabaseConnection>
    static absl::optional<KeyBean> getImplementation(DatabaseConnection& db, const std::string& hash)
    {
        const auto table = getTable();

        try
        {
            for (const auto& row : db(select(all_of(table)).from(table).where(table.keyHash == hash).limit(1U)))
            {
                return constructor(row);
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }

        return absl::nullopt;
    }

    template <typename DatabaseConnection, typename ColumnName, typename ColumnType>
    static List<KeyBean> getByImplementation(DatabaseConnection& db, const ColumnName& column, const ColumnType& column_value)
    {
        const auto table = getTable();

        List<KeyBean> result(0);

        try
        {
            for (const auto& row : db(select(all_of(table)).from(table).where(column == column_value)))
            {
                result.push_back(constructor(row));
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }

        return result;
    }

    template <typename DatabaseConnection>
    static void removeImplementation(DatabaseConnection& db, const std::string& hash)
    {
        const auto table = getTable();

        db(remove_from(table).where(table.keyHash == hash));
    }

    template <typename DatabaseConnection, typename ColumnName, typename ColumnType>
    static void removeByImplementation(DatabaseConnection& db, const ColumnName& column, const ColumnType& column_value)
    {
        const auto table = getTable();

        db(remove_from(table).where(column == column_value));
    }

    template <typename DatabaseConnection>
    static std::string insertImplementation(DatabaseConnection& db, KeyBean& bean)
    {
        try
        {
            const auto table = getTable();

            if (!bean.key_hash) bean.key_hash = qs::util::Hash::get();

            auto prepareStatement = db.prepare(sqlpp::insert_into(table).set(
                (table.keyHash = parameter(table.keyHash)),
                (table.name = parameter(table.name)),
                (table.userHash = parameter(table.userHash)),
                (table.value = parameter(table.value))));

            if (bean.key_hash)
            {
                prepareStatement.params.keyHash = (*bean.key_hash);
            }
            prepareStatement.params.name = bean.name;
            prepareStatement.params.userHash = bean.user_hash;
            prepareStatement.params.value = bean.value;

            db(prepareStatement);

            return *bean.key_hash;
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    template <typename DatabaseConnection>
    static void updateImplementation(DatabaseConnection& db, const KeyBean& bean)
    {
        try
        {
            const auto table = getTable();

            auto optOrigBean = getImplementation(db, *bean.key_hash);
            auto& origBean = *optOrigBean;

            if (bean.key_hash)
            {
                origBean.key_hash = bean.key_hash;
            }
            origBean.name = bean.name;
            origBean.user_hash = bean.user_hash;
            origBean.value = bean.value;

            overrideImplementation(db, origBean);
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    template <typename DatabaseConnection>
    static void overrideImplementation(DatabaseConnection& db, const KeyBean& bean)
    {
        try
        {
            const auto table = getTable();

            auto prepareStatement = db.prepare(sqlpp::update(table).set(
                                                                       (table.keyHash = parameter(table.keyHash)),
                                                                       (table.name = parameter(table.name)),
                                                                       (table.userHash = parameter(table.userHash)),
                                                                       (table.value = parameter(table.value)))
                                                   .where(table.keyHash == *bean.key_hash));

            if (bean.key_hash)
            {
                prepareStatement.params.keyHash = (*bean.key_hash);
            }
            prepareStatement.params.name = bean.name;
            prepareStatement.params.userHash = bean.user_hash;
            prepareStatement.params.value = bean.value;

            db(prepareStatement);
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }
};
}

namespace qs {

template <>
class ORM<PerspectiveBean>
{
public:
    static qs::orm::Perspective& getTable()
    {
        static qs::orm::Perspective table{};
        return table;
    }

    template <typename Row>
    static PerspectiveBean constructor(const Row& row)
    {
        PerspectiveBean bean;
        if (!row.perspectiveHash.is_null()) bean.perspective_hash = row.perspectiveHash.value();
        bean.defined_query = row.definedQuery.value();
        bean.name = row.name.value();
        if (!row.ordering.is_null()) bean.ordering = row.ordering.value();
        if (!row.refinedQuery.is_null()) bean.refined_query = row.refinedQuery.value();
        if (!row.userHash.is_null()) bean.user_hash = row.userHash.value();
        return bean;
    }

    static List<PerspectiveBean> query(sqlpp::connection& db, const std::string& sqlQuery)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return queryImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), sqlQuery);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return queryImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), sqlQuery);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static absl::optional<PerspectiveBean> get(sqlpp::connection& db, const std::string& hash)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return getImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), hash);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return getImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), hash);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    template <typename ColumnName, typename ColumnType>
    static List<PerspectiveBean> getBy(sqlpp::connection& db, const ColumnName& column, const ColumnType& column_value)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return getByImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), column, column_value);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return getByImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), column, column_value);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void remove(sqlpp::connection& db, const std::string& hash)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return removeImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), hash);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return removeImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), hash);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    template <typename ColumnName, typename ColumnType>
    static void removeBy(sqlpp::connection& db, const ColumnName& column, const ColumnType& column_value)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return removeByImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), column, column_value);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return removeByImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), column, column_value);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static std::string insert(sqlpp::connection& db, PerspectiveBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return insertImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return insertImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void update(sqlpp::connection& db, const PerspectiveBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return updateImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return updateImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void override(sqlpp::connection& db, const PerspectiveBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return overrideImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return overrideImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

private:
    template <typename DatabaseConnection>
    static List<PerspectiveBean> queryImplementation(DatabaseConnection& db, const std::string& sqlQuery)
    {
        const auto table = getTable();

        List<PerspectiveBean> result(0);

        try
        {
            for (const auto& row : db(
                     sqlpp::custom_query(sqlpp::verbatim(sqlQuery))
                         .with_result_type_of(sqlpp::select(all_of(table)))))
            {
                result.push_back(constructor(row));
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
            return result;
        }

        return result;
    }

    template <typename DatabaseConnection>
    static absl::optional<PerspectiveBean> getImplementation(DatabaseConnection& db, const std::string& hash)
    {
        const auto table = getTable();

        try
        {
            for (const auto& row : db(select(all_of(table)).from(table).where(table.perspectiveHash == hash).limit(1U)))
            {
                return constructor(row);
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }

        return absl::nullopt;
    }

    template <typename DatabaseConnection, typename ColumnName, typename ColumnType>
    static List<PerspectiveBean> getByImplementation(DatabaseConnection& db, const ColumnName& column, const ColumnType& column_value)
    {
        const auto table = getTable();

        List<PerspectiveBean> result(0);

        try
        {
            for (const auto& row : db(select(all_of(table)).from(table).where(column == column_value)))
            {
                result.push_back(constructor(row));
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }

        return result;
    }

    template <typename DatabaseConnection>
    static void removeImplementation(DatabaseConnection& db, const std::string& hash)
    {
        const auto table = getTable();

        db(remove_from(table).where(table.perspectiveHash == hash));
    }

    template <typename DatabaseConnection, typename ColumnName, typename ColumnType>
    static void removeByImplementation(DatabaseConnection& db, const ColumnName& column, const ColumnType& column_value)
    {
        const auto table = getTable();

        db(remove_from(table).where(column == column_value));
    }

    template <typename DatabaseConnection>
    static std::string insertImplementation(DatabaseConnection& db, PerspectiveBean& bean)
    {
        try
        {
            const auto table = getTable();

            if (!bean.perspective_hash) bean.perspective_hash = qs::util::Hash::get();

            auto prepareStatement = db.prepare(sqlpp::insert_into(table).set(
                (table.perspectiveHash = parameter(table.perspectiveHash)),
                (table.definedQuery = parameter(table.definedQuery)),
                (table.name = parameter(table.name)),
                (table.ordering = parameter(table.ordering)),
                (table.refinedQuery = parameter(table.refinedQuery)),
                (table.userHash = parameter(table.userHash))));

            if (bean.perspective_hash)
            {
                prepareStatement.params.perspectiveHash = (*bean.perspective_hash);
            }
            prepareStatement.params.definedQuery = bean.defined_query;
            prepareStatement.params.name = bean.name;
            if (bean.ordering)
            {
                prepareStatement.params.ordering = (*bean.ordering);
            }
            if (bean.refined_query)
            {
                prepareStatement.params.refinedQuery = (*bean.refined_query);
            }
            if (bean.user_hash)
            {
                prepareStatement.params.userHash = (*bean.user_hash);
            }

            db(prepareStatement);

            return *bean.perspective_hash;
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    template <typename DatabaseConnection>
    static void updateImplementation(DatabaseConnection& db, const PerspectiveBean& bean)
    {
        try
        {
            const auto table = getTable();

            auto optOrigBean = getImplementation(db, *bean.perspective_hash);
            auto& origBean = *optOrigBean;

            if (bean.perspective_hash)
            {
                origBean.perspective_hash = bean.perspective_hash;
            }
            origBean.defined_query = bean.defined_query;
            origBean.name = bean.name;
            if (bean.ordering)
            {
                origBean.ordering = bean.ordering;
            }
            if (bean.refined_query)
            {
                origBean.refined_query = bean.refined_query;
            }
            if (bean.user_hash)
            {
                origBean.user_hash = bean.user_hash;
            }

            overrideImplementation(db, origBean);
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    template <typename DatabaseConnection>
    static void overrideImplementation(DatabaseConnection& db, const PerspectiveBean& bean)
    {
        try
        {
            const auto table = getTable();

            auto prepareStatement = db.prepare(sqlpp::update(table).set(
                                                                       (table.perspectiveHash = parameter(table.perspectiveHash)),
                                                                       (table.definedQuery = parameter(table.definedQuery)),
                                                                       (table.name = parameter(table.name)),
                                                                       (table.ordering = parameter(table.ordering)),
                                                                       (table.refinedQuery = parameter(table.refinedQuery)),
                                                                       (table.userHash = parameter(table.userHash)))
                                                   .where(table.perspectiveHash == *bean.perspective_hash));

            if (bean.perspective_hash)
            {
                prepareStatement.params.perspectiveHash = (*bean.perspective_hash);
            }
            prepareStatement.params.definedQuery = bean.defined_query;
            prepareStatement.params.name = bean.name;
            if (bean.ordering)
            {
                prepareStatement.params.ordering = (*bean.ordering);
            }
            if (bean.refined_query)
            {
                prepareStatement.params.refinedQuery = (*bean.refined_query);
            }
            if (bean.user_hash)
            {
                prepareStatement.params.userHash = (*bean.user_hash);
            }

            db(prepareStatement);
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }
};
}

namespace qs {

template <>
class ORM<UserBean>
{
public:
    static qs::orm::User& getTable()
    {
        static qs::orm::User table{};
        return table;
    }

    template <typename Row>
    static UserBean constructor(const Row& row)
    {
        UserBean bean;
        if (!row.userHash.is_null()) bean.user_hash = row.userHash.value();
        bean.databaseConnectionString = row.databaseConnectionString.value();
        bean.password = row.password.value();
        bean.storageConnectionString = row.storageConnectionString.value();
        bean.username = row.username.value();
        return bean;
    }

    static List<UserBean> query(sqlpp::connection& db, const std::string& sqlQuery)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return queryImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), sqlQuery);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return queryImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), sqlQuery);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static absl::optional<UserBean> get(sqlpp::connection& db, const std::string& hash)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return getImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), hash);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return getImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), hash);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    template <typename ColumnName, typename ColumnType>
    static List<UserBean> getBy(sqlpp::connection& db, const ColumnName& column, const ColumnType& column_value)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return getByImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), column, column_value);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return getByImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), column, column_value);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void remove(sqlpp::connection& db, const std::string& hash)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return removeImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), hash);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return removeImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), hash);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    template <typename ColumnName, typename ColumnType>
    static void removeBy(sqlpp::connection& db, const ColumnName& column, const ColumnType& column_value)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return removeByImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), column, column_value);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return removeByImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), column, column_value);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static std::string insert(sqlpp::connection& db, UserBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return insertImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return insertImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void update(sqlpp::connection& db, const UserBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return updateImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return updateImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void override(sqlpp::connection& db, const UserBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return overrideImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return overrideImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

private:
    template <typename DatabaseConnection>
    static List<UserBean> queryImplementation(DatabaseConnection& db, const std::string& sqlQuery)
    {
        const auto table = getTable();

        List<UserBean> result(0);

        try
        {
            for (const auto& row : db(
                     sqlpp::custom_query(sqlpp::verbatim(sqlQuery))
                         .with_result_type_of(sqlpp::select(all_of(table)))))
            {
                result.push_back(constructor(row));
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
            return result;
        }

        return result;
    }

    template <typename DatabaseConnection>
    static absl::optional<UserBean> getImplementation(DatabaseConnection& db, const std::string& hash)
    {
        const auto table = getTable();

        try
        {
            for (const auto& row : db(select(all_of(table)).from(table).where(table.userHash == hash).limit(1U)))
            {
                return constructor(row);
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }

        return absl::nullopt;
    }

    template <typename DatabaseConnection, typename ColumnName, typename ColumnType>
    static List<UserBean> getByImplementation(DatabaseConnection& db, const ColumnName& column, const ColumnType& column_value)
    {
        const auto table = getTable();

        List<UserBean> result(0);

        try
        {
            for (const auto& row : db(select(all_of(table)).from(table).where(column == column_value)))
            {
                result.push_back(constructor(row));
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }

        return result;
    }

    template <typename DatabaseConnection>
    static void removeImplementation(DatabaseConnection& db, const std::string& hash)
    {
        const auto table = getTable();

        db(remove_from(table).where(table.userHash == hash));
    }

    template <typename DatabaseConnection, typename ColumnName, typename ColumnType>
    static void removeByImplementation(DatabaseConnection& db, const ColumnName& column, const ColumnType& column_value)
    {
        const auto table = getTable();

        db(remove_from(table).where(column == column_value));
    }

    template <typename DatabaseConnection>
    static std::string insertImplementation(DatabaseConnection& db, UserBean& bean)
    {
        try
        {
            const auto table = getTable();

            if (!bean.user_hash) bean.user_hash = qs::util::Hash::get();

            auto prepareStatement = db.prepare(sqlpp::insert_into(table).set(
                (table.userHash = parameter(table.userHash)),
                (table.databaseConnectionString = parameter(table.databaseConnectionString)),
                (table.password = parameter(table.password)),
                (table.storageConnectionString = parameter(table.storageConnectionString)),
                (table.username = parameter(table.username))));

            if (bean.user_hash)
            {
                prepareStatement.params.userHash = (*bean.user_hash);
            }
            prepareStatement.params.databaseConnectionString = bean.databaseConnectionString;
            prepareStatement.params.password = bean.password;
            prepareStatement.params.storageConnectionString = bean.storageConnectionString;
            prepareStatement.params.username = bean.username;

            db(prepareStatement);

            return *bean.user_hash;
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    template <typename DatabaseConnection>
    static void updateImplementation(DatabaseConnection& db, const UserBean& bean)
    {
        try
        {
            const auto table = getTable();

            auto optOrigBean = getImplementation(db, *bean.user_hash);
            auto& origBean = *optOrigBean;

            if (bean.user_hash)
            {
                origBean.user_hash = bean.user_hash;
            }
            origBean.databaseConnectionString = bean.databaseConnectionString;
            origBean.password = bean.password;
            origBean.storageConnectionString = bean.storageConnectionString;
            origBean.username = bean.username;

            overrideImplementation(db, origBean);
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    template <typename DatabaseConnection>
    static void overrideImplementation(DatabaseConnection& db, const UserBean& bean)
    {
        try
        {
            const auto table = getTable();

            auto prepareStatement = db.prepare(sqlpp::update(table).set(
                                                                       (table.userHash = parameter(table.userHash)),
                                                                       (table.databaseConnectionString = parameter(table.databaseConnectionString)),
                                                                       (table.password = parameter(table.password)),
                                                                       (table.storageConnectionString = parameter(table.storageConnectionString)),
                                                                       (table.username = parameter(table.username)))
                                                   .where(table.userHash == *bean.user_hash));

            if (bean.user_hash)
            {
                prepareStatement.params.userHash = (*bean.user_hash);
            }
            prepareStatement.params.databaseConnectionString = bean.databaseConnectionString;
            prepareStatement.params.password = bean.password;
            prepareStatement.params.storageConnectionString = bean.storageConnectionString;
            prepareStatement.params.username = bean.username;

            db(prepareStatement);
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }
};
}
