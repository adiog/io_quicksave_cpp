// This file is an AUTOGENERATED part of beans project.
// Copyright (c) 2017 Aleksander Gajewski <adiog@quicksave.io>.

#ifndef VIEWBEAN_H
#define VIEWBEAN_H

#include "rapidjson/document.h"
#include "rapidjson/stringbuffer.h"
#include "rapidjson/writer.h"
#include <CppBeans.h>
#include <folly/io/IOBuf.h>
#include <memory>

class ViewBean {
public:
  ViewBean() = default;

  ViewBean(const char *json) : ViewBean(rapidjson::Document{}.Parse(json)) {}

  ViewBean(std::optional<std::string> view_hash, std::string defined_query,
           std::string name, List<std::string> ordering,
           std::string refined_query, std::string user_hash)
      : view_hash(view_hash), defined_query(defined_query), name(name),
        ordering(ordering), refined_query(refined_query), user_hash(user_hash) {
  }

  ViewBean(const rapidjson::Value &value) {
    if (value.HasMember(view_hash_label))
      this->view_hash = std::make_optional<std::string>(
          Typoid<std::string>::FromValue(value[view_hash_label]));
    if (value.HasMember(defined_query_label))
      this->defined_query =
          Typoid<std::string>::FromValue(value[defined_query_label]);
    else
      throw(missing_mandatory_field(defined_query_label));
    if (value.HasMember(name_label))
      this->name = Typoid<std::string>::FromValue(value[name_label]);
    else
      throw(missing_mandatory_field(name_label));
    if (value.HasMember(ordering_label))
      this->ordering =
          Typoid<List<std::string>>::FromValue(value[ordering_label]);
    else
      throw(missing_mandatory_field(ordering_label));
    if (value.HasMember(refined_query_label))
      this->refined_query =
          Typoid<std::string>::FromValue(value[refined_query_label]);
    else
      throw(missing_mandatory_field(refined_query_label));
    if (value.HasMember(user_hash_label))
      this->user_hash = Typoid<std::string>::FromValue(value[user_hash_label]);
    else
      throw(missing_mandatory_field(user_hash_label));
  }

  void update(ViewBean bean) {
    if (bean.view_hash)
      view_hash = bean.view_hash;
    defined_query = bean.defined_query;
    name = bean.name;
    ordering = bean.ordering;
    refined_query = bean.refined_query;
    user_hash = bean.user_hash;
  }

  template <typename Writer> void Serialize(Writer &writer) const {
    writer.StartObject();
    if (view_hash)
      writer.String(view_hash_label);
    if (view_hash)
      Typoid<std::string>::Serialize(*view_hash, writer);
    writer.String(defined_query_label);
    Typoid<std::string>::Serialize(defined_query, writer);
    writer.String(name_label);
    Typoid<std::string>::Serialize(name, writer);
    writer.String(ordering_label);
    Typoid<List<std::string>>::Serialize(ordering, writer);
    writer.String(refined_query_label);
    Typoid<std::string>::Serialize(refined_query, writer);
    writer.String(user_hash_label);
    Typoid<std::string>::Serialize(user_hash, writer);
    writer.EndObject();
  }

  std::string to_string() const {
    rapidjson::StringBuffer s;
    rapidjson::Writer<rapidjson::StringBuffer> writer(s);
    Serialize(writer);
    return s.GetString();
  }

  operator std::unique_ptr<folly::IOBuf>() const {
    return folly::IOBuf::copyBuffer(::serialize(*this));
  }

  const char *__name__ = "ViewBean";
  std::optional<std::string> view_hash;
  const char *view_hash_label = "view_hash";
  std::string defined_query;
  const char *defined_query_label = "defined_query";
  std::string name;
  const char *name_label = "name";
  List<std::string> ordering;
  const char *ordering_label = "ordering";
  std::string refined_query;
  const char *refined_query_label = "refined_query";
  std::string user_hash;
  const char *user_hash_label = "user_hash";
};

#endif
