// This file is an AUTOGENERATED part of beans project.
// Copyright (c) 2017 Aleksander Gajewski <adiog@quicksave.io>.

#pragma once

#include <iostream>
#include <string>

#include <folly/Format.h>

#include <sqlpp11/alias_provider.h>
#include <sqlpp11/char_sequence.h>
#include <sqlpp11/column_types.h>
#include <sqlpp11/functions.h>
#include <sqlpp11/insert.h>
#include <sqlpp11/multi_column.h>
#include <sqlpp11/remove.h>
#include <sqlpp11/select.h>
#include <sqlpp11/table.h>
#include <sqlpp11/transaction.h>
#include <sqlpp11/update.h>

#include <sqlpp11/postgresql/connection.h>
#include <sqlpp11/sqlite3/connection.h>

#include <CppBeans.h>

#include <qsgen/bean/ABI.h>
#include <qsgen/orm/sqlppTables.h>

#include <qs/util/hash.h>


namespace qsgen {
namespace orm {

template <typename T>
class ORM;
}
}
namespace qsgen {
namespace orm {

using namespace sqlpp;

template <>
class ORM<MetaBean>
{
public:
    static qsgen::orm::Meta& getTable()
    {
        static qsgen::orm::Meta table{};
        return table;
    }

    template <typename Row>
    static MetaBean constructor(const Row& row)
    {
        MetaBean bean;
        if (row.metaHash.is_null()) bean.meta_hash = row.metaHash.value();
        if (row.author.is_null()) bean.author = row.author.value();
        if (row.createdAt.is_null()) bean.created_at = row.createdAt.value();
        if (row.icon.is_null()) bean.icon = row.icon.value();
        if (row.metaType.is_null()) bean.meta_type = row.metaType.value();
        if (row.modifiedAt.is_null()) bean.modified_at = row.modifiedAt.value();
        if (row.name.is_null()) bean.name = row.name.value();
        if (row.sourceTitle.is_null()) bean.source_title = row.sourceTitle.value();
        if (row.sourceUrl.is_null()) bean.source_url = row.sourceUrl.value();
        if (row.text.is_null()) bean.text = row.text.value();
        if (row.userHash.is_null()) bean.user_hash = row.userHash.value();
        return bean;
    }

    static absl::optional<MetaBean> get(sqlpp::connection& db, const std::string& hash)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return getImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), hash);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return getImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), hash);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    template <typename ColumnName, typename ColumnType>
    static List<MetaBean> getBy(sqlpp::connection& db, const ColumnName& column, const ColumnType& column_value)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return getByImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), column, column_value);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return getByImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), column, column_value);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void remove(sqlpp::connection& db, const std::string& hash)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return removeImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), hash);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return removeImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), hash);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    template <typename ColumnName, typename ColumnType>
    static void removeBy(sqlpp::connection& db, const ColumnName& column, const ColumnType& column_value)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return removeByImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), column, column_value);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return removeByImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), column, column_value);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static std::string insert(sqlpp::connection& db, MetaBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return insertImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return insertImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void update(sqlpp::connection& db, const MetaBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return updateImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return updateImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void override(sqlpp::connection& db, const MetaBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return overrideImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return overrideImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }


    /*
    static List<___BEAN___Bean> sql(PostgresTransactionImpl* tr, std::string sql)
    {
        List<___BEAN___Bean> result(0);

        try
        {
            const char * query = sql.c_str();

            auto query_result = tr->execute(query);

            for(int rowIndex = 0; rowIndex < query_result.size(); ++rowIndex){
                auto row = query_result.at(rowIndex);

                ___BEAN___Bean bean;

                int getIndex = 0;

                ___RETRIEVE___

                result.push_back(bean);
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
            return result;
        }

        return result;
    }
*/
private:
    template <typename DatabaseConnection>
    static absl::optional<MetaBean> getImplementation(DatabaseConnection& db, const std::string& hash)
    {
        const auto table = getTable();

        try
        {
            for (const auto& row : db(select(all_of(table)).from(table).where(table.metaHash == hash).limit(1U)))
            {
                return constructor(row);
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }

        return absl::nullopt;
    }

    template <typename DatabaseConnection, typename ColumnName, typename ColumnType>
    static List<MetaBean> getByImplementation(DatabaseConnection& db, const ColumnName& column, const ColumnType& column_value)
    {
        const auto table = getTable();

        List<MetaBean> result(0);

        try
        {
            for (const auto& row : db(select(all_of(table)).from(table).where(column == column_value)))
            {
                result.emplace_back(constructor(row));
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }

        return result;
    }

    template <typename DatabaseConnection>
    static void removeImplementation(DatabaseConnection& db, const std::string& hash)
    {
        const auto table = getTable();

        db(remove_from(table).where(table.metaHash == hash));
    }

    template <typename DatabaseConnection, typename ColumnName, typename ColumnType>
    static void removeByImplementation(sqlpp::connection& db, const ColumnName& column, const ColumnType& column_value)
    {
        const auto table = getTable();

        db(remove_from(table).where(column == column_value));
    }

    template <typename DatabaseConnection>
    static std::string insertImplementation(DatabaseConnection& db, MetaBean& bean)
    {
        try
        {
            const auto table = getTable();

            if (!bean.meta_hash) bean.meta_hash = qs::util::Hash::get();

            db(sqlpp::insert_into(table).set(
                (table.metaHash = ((bean.meta_hash) ? (*bean.meta_hash) : nullptr)),
                (table.author = ((bean.author) ? (*bean.author) : nullptr)),
                (table.createdAt = ((bean.created_at) ? (*bean.created_at) : nullptr)),
                (table.icon = ((bean.icon) ? (*bean.icon) : nullptr)),
                (table.metaType = ((bean.meta_type) ? (*bean.meta_type) : nullptr)),
                (table.modifiedAt = ((bean.modified_at) ? (*bean.modified_at) : nullptr)),
                (table.name = ((bean.name) ? (*bean.name) : nullptr)),
                (table.sourceTitle = ((bean.source_title) ? (*bean.source_title) : nullptr)),
                (table.sourceUrl = ((bean.source_url) ? (*bean.source_url) : nullptr)),
                (table.text = ((bean.text) ? (*bean.text) : nullptr)),
                (table.userHash = ((bean.user_hash) ? (*bean.user_hash) : nullptr))));

            return *bean.meta_hash;
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    template <typename DatabaseConnection>
    static void updateImplementation(DatabaseConnection& db, const MetaBean& bean)
    {
        try
        {
            const auto table = getTable();

            auto prepare_update = db.prepare(sqlpp::update(table).set(
                                                                     (table.metaHash = parameter(table.metaHash)),
                                                                     (table.author = parameter(table.author)),
                                                                     (table.createdAt = parameter(table.createdAt)),
                                                                     (table.icon = parameter(table.icon)),
                                                                     (table.metaType = parameter(table.metaType)),
                                                                     (table.modifiedAt = parameter(table.modifiedAt)),
                                                                     (table.name = parameter(table.name)),
                                                                     (table.sourceTitle = parameter(table.sourceTitle)),
                                                                     (table.sourceUrl = parameter(table.sourceUrl)),
                                                                     (table.text = parameter(table.text)),
                                                                     (table.userHash = parameter(table.userHash)))
                                                 .where(table.metaHash == *bean.meta_hash));

            if (bean.meta_hash) prepare_update.params.metaHash = (*bean.meta_hash);
            if (bean.author) prepare_update.params.author = (*bean.author);
            if (bean.created_at) prepare_update.params.createdAt = (*bean.created_at);
            if (bean.icon) prepare_update.params.icon = (*bean.icon);
            if (bean.meta_type) prepare_update.params.metaType = (*bean.meta_type);
            if (bean.modified_at) prepare_update.params.modifiedAt = (*bean.modified_at);
            if (bean.name) prepare_update.params.name = (*bean.name);
            if (bean.source_title) prepare_update.params.sourceTitle = (*bean.source_title);
            if (bean.source_url) prepare_update.params.sourceUrl = (*bean.source_url);
            if (bean.text) prepare_update.params.text = (*bean.text);
            if (bean.user_hash) prepare_update.params.userHash = (*bean.user_hash);
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    template <typename DatabaseConnection>
    static void overrideImplementation(DatabaseConnection& db, const MetaBean& bean)
    {
        try
        {
            const auto table = getTable();

            auto prepare_update = db.prepare(sqlpp::update(table).set(
                                                                     (table.metaHash = parameter(table.metaHash)),
                                                                     (table.author = parameter(table.author)),
                                                                     (table.createdAt = parameter(table.createdAt)),
                                                                     (table.icon = parameter(table.icon)),
                                                                     (table.metaType = parameter(table.metaType)),
                                                                     (table.modifiedAt = parameter(table.modifiedAt)),
                                                                     (table.name = parameter(table.name)),
                                                                     (table.sourceTitle = parameter(table.sourceTitle)),
                                                                     (table.sourceUrl = parameter(table.sourceUrl)),
                                                                     (table.text = parameter(table.text)),
                                                                     (table.userHash = parameter(table.userHash)))
                                                 .where(table.metaHash == *bean.meta_hash));

            if (bean.meta_hash)
            {
                prepare_update.params.metaHash = (*bean.meta_hash);
            }
            else
            {
                prepare_update.params.metaHash = nullptr;
            }
            if (bean.author)
            {
                prepare_update.params.author = (*bean.author);
            }
            else
            {
                prepare_update.params.author = nullptr;
            }
            if (bean.created_at)
            {
                prepare_update.params.createdAt = (*bean.created_at);
            }
            else
            {
                prepare_update.params.createdAt = nullptr;
            }
            if (bean.icon)
            {
                prepare_update.params.icon = (*bean.icon);
            }
            else
            {
                prepare_update.params.icon = nullptr;
            }
            if (bean.meta_type)
            {
                prepare_update.params.metaType = (*bean.meta_type);
            }
            else
            {
                prepare_update.params.metaType = nullptr;
            }
            if (bean.modified_at)
            {
                prepare_update.params.modifiedAt = (*bean.modified_at);
            }
            else
            {
                prepare_update.params.modifiedAt = nullptr;
            }
            if (bean.name)
            {
                prepare_update.params.name = (*bean.name);
            }
            else
            {
                prepare_update.params.name = nullptr;
            }
            if (bean.source_title)
            {
                prepare_update.params.sourceTitle = (*bean.source_title);
            }
            else
            {
                prepare_update.params.sourceTitle = nullptr;
            }
            if (bean.source_url)
            {
                prepare_update.params.sourceUrl = (*bean.source_url);
            }
            else
            {
                prepare_update.params.sourceUrl = nullptr;
            }
            if (bean.text)
            {
                prepare_update.params.text = (*bean.text);
            }
            else
            {
                prepare_update.params.text = nullptr;
            }
            if (bean.user_hash)
            {
                prepare_update.params.userHash = (*bean.user_hash);
            }
            else
            {
                prepare_update.params.userHash = nullptr;
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }
};
}
}

namespace qsgen {
namespace orm {

using namespace sqlpp;

template <>
class ORM<UserBean>
{
public:
    static qsgen::orm::User& getTable()
    {
        static qsgen::orm::User table{};
        return table;
    }

    template <typename Row>
    static UserBean constructor(const Row& row)
    {
        UserBean bean;
        if (row.userHash.is_null()) bean.user_hash = row.userHash.value();
        bean.databaseConnectionString = row.databaseConnectionString.value();
        bean.password = row.password.value();
        bean.storageConnectionString = row.storageConnectionString.value();
        bean.username = row.username.value();
        return bean;
    }

    static absl::optional<UserBean> get(sqlpp::connection& db, const std::string& hash)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return getImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), hash);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return getImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), hash);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    template <typename ColumnName, typename ColumnType>
    static List<UserBean> getBy(sqlpp::connection& db, const ColumnName& column, const ColumnType& column_value)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return getByImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), column, column_value);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return getByImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), column, column_value);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void remove(sqlpp::connection& db, const std::string& hash)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return removeImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), hash);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return removeImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), hash);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    template <typename ColumnName, typename ColumnType>
    static void removeBy(sqlpp::connection& db, const ColumnName& column, const ColumnType& column_value)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return removeByImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), column, column_value);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return removeByImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), column, column_value);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static std::string insert(sqlpp::connection& db, UserBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return insertImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return insertImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void update(sqlpp::connection& db, const UserBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return updateImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return updateImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }

    static void override(sqlpp::connection& db, const UserBean& bean)
    {
        if (db.getRTTI() == sqlpp::connection::connection_backend::SQLITE3)
        {
            return overrideImplementation(*dynamic_cast<sqlpp::sqlite3::connection*>(&db), bean);
        }
        else if (db.getRTTI() == sqlpp::connection::connection_backend::POSTGRESQL)
        {
            return overrideImplementation(*dynamic_cast<sqlpp::postgresql::connection*>(&db), bean);
        }
        else
        {
            throw std::runtime_error("");
        }
    }


    /*
    static List<___BEAN___Bean> sql(PostgresTransactionImpl* tr, std::string sql)
    {
        List<___BEAN___Bean> result(0);

        try
        {
            const char * query = sql.c_str();

            auto query_result = tr->execute(query);

            for(int rowIndex = 0; rowIndex < query_result.size(); ++rowIndex){
                auto row = query_result.at(rowIndex);

                ___BEAN___Bean bean;

                int getIndex = 0;

                ___RETRIEVE___

                result.push_back(bean);
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
            return result;
        }

        return result;
    }
*/
private:
    template <typename DatabaseConnection>
    static absl::optional<UserBean> getImplementation(DatabaseConnection& db, const std::string& hash)
    {
        const auto table = getTable();

        try
        {
            for (const auto& row : db(select(all_of(table)).from(table).where(table.userHash == hash).limit(1U)))
            {
                return constructor(row);
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }

        return absl::nullopt;
    }

    template <typename DatabaseConnection, typename ColumnName, typename ColumnType>
    static List<UserBean> getByImplementation(DatabaseConnection& db, const ColumnName& column, const ColumnType& column_value)
    {
        const auto table = getTable();

        List<UserBean> result(0);

        try
        {
            for (const auto& row : db(select(all_of(table)).from(table).where(column == column_value)))
            {
                result.emplace_back(constructor(row));
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }

        return result;
    }

    template <typename DatabaseConnection>
    static void removeImplementation(DatabaseConnection& db, const std::string& hash)
    {
        const auto table = getTable();

        db(remove_from(table).where(table.userHash == hash));
    }

    template <typename DatabaseConnection, typename ColumnName, typename ColumnType>
    static void removeByImplementation(sqlpp::connection& db, const ColumnName& column, const ColumnType& column_value)
    {
        const auto table = getTable();

        db(remove_from(table).where(column == column_value));
    }

    template <typename DatabaseConnection>
    static std::string insertImplementation(DatabaseConnection& db, UserBean& bean)
    {
        try
        {
            const auto table = getTable();

            if (!bean.user_hash) bean.user_hash = qs::util::Hash::get();

            db(sqlpp::insert_into(table).set(
                (table.userHash = ((bean.user_hash) ? (*bean.user_hash) : nullptr)),
                (table.databaseConnectionString = bean.databaseConnectionString),
                (table.password = bean.password),
                (table.storageConnectionString = bean.storageConnectionString),
                (table.username = bean.username)));

            return *bean.user_hash;
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    template <typename DatabaseConnection>
    static void updateImplementation(DatabaseConnection& db, const UserBean& bean)
    {
        try
        {
            const auto table = getTable();

            auto prepare_update = db.prepare(sqlpp::update(table).set(
                                                                     (table.userHash = parameter(table.userHash)),
                                                                     (table.databaseConnectionString = parameter(table.databaseConnectionString)),
                                                                     (table.password = parameter(table.password)),
                                                                     (table.storageConnectionString = parameter(table.storageConnectionString)),
                                                                     (table.username = parameter(table.username)))
                                                 .where(table.userHash == *bean.user_hash));

            if (bean.user_hash) prepare_update.params.userHash = (*bean.user_hash);
            prepare_update.params.databaseConnectionString = bean.databaseConnectionString;
            prepare_update.params.password = bean.password;
            prepare_update.params.storageConnectionString = bean.storageConnectionString;
            prepare_update.params.username = bean.username;
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    template <typename DatabaseConnection>
    static void overrideImplementation(DatabaseConnection& db, const UserBean& bean)
    {
        try
        {
            const auto table = getTable();

            auto prepare_update = db.prepare(sqlpp::update(table).set(
                                                                     (table.userHash = parameter(table.userHash)),
                                                                     (table.databaseConnectionString = parameter(table.databaseConnectionString)),
                                                                     (table.password = parameter(table.password)),
                                                                     (table.storageConnectionString = parameter(table.storageConnectionString)),
                                                                     (table.username = parameter(table.username)))
                                                 .where(table.userHash == *bean.user_hash));

            if (bean.user_hash)
            {
                prepare_update.params.userHash = (*bean.user_hash);
            }
            else
            {
                prepare_update.params.userHash = nullptr;
            }
            prepare_update.params.databaseConnectionString = bean.databaseConnectionString;
            prepare_update.params.password = bean.password;
            prepare_update.params.storageConnectionString = bean.storageConnectionString;
            prepare_update.params.username = bean.username;
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }
};
}
}
